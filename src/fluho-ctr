#!/bin/bash

###############################################################################
# Fluho
# Controller
#
# Written by Juan Jose Castro Sotelo
# Licensed under terms of GPLv3
#
###############################################################################




do_init()
{
  local version=${1:-"."}
  
  echodbg "usa init\n"
  echodbg "version: $version\n"
  echodbg "feature: $OPTFEATURE\n"
  echodbg "feature name: $feature_name\n"
  
  local vmajor=`extract_vmajor $version`
  local vminor=`extract_vminor $version`
  local vrev=`extract_vrev $version`
  local vstatus=`extract_vstatus $version`
  
  local success=false
  
  if [[ "$OPTFEATURE" == true && "$vmajor" == "" && "$vminor" == "" ]]; then
    # Check that version number is specified for FEATURE initialization
    # Note: For version initialization, it defaults to 0.0 if not specified
    vmajor="`get_currentversion | extract_vmajor`"; vmajor="${vmajor:-"{major}"}"
    vminor="`get_currentversion | extract_vminor`"; vminor="${vminor:-"{minor}"}"
    feature_name="${feature_name:-"{feature_name}"}"

    echoerr "\
Version number must be specified as major.minor to initialize a feature
To initialize development of a feature of a version, use a command like this:

    $ ${0##*/} init v${vmajor}.${vminor} --feature ${feature_name}"
    exit 1
  fi
  
  vmajor=${vmajor:-0}
  vminor=${vminor:-0}
  
  if [ "$vrev" != "" -o "$vstatus" != "" ]; then
    echoerr "\
Only major.minor version can be initialized. Use:

    $ ${0##*/} init ${vmajor}.${vminor}"
    exit 1
  fi
  
  # New major version init
  if ! exist_vmajor "$vmajor" development; then
    # Check the v0.0 is used if fluho not initialized
    if [ $vmajor -ne 0 -o $vminor -ne 0 ] && ! is_initialized; then
      show_notinitialized_error
      exit 1  
    fi

    if ! askYes "\
Are you sure you want to init the version ${vmajor}.${vminor}" "No"
    then 
      echo "\
Version initialization canceled!"
      exit 2
    fi
      
    init_vmajor "$vmajor" "$vminor" && success=true 

    if [ "$success" == true ]; then 
      echo "\
Created branches"
    else
      echoerr "\
Cannot be successfully initialized because a failure creating branches
Does the cutting-edge branch exist and is it correctly initialized?"
      exit 1
    fi
    
    if [ $vmajor -eq 0 -a $vminor -eq 0 ]; then
      # Start versioning in a new repo
      vcs_create_lightweighttag "v0.0.0-alpha" && \
      vcs_create_lightweighttag "v0.0-alpha1" && \
      vcs_create_lightweighttag "v0.0.0" && success=true
      if [ "$success" == true ]; then 
        echo "\
Created tags"
        vcs_checkout "dev/v0.0"
      else
        echoerr "\
Cannot be successfully initialized because a failure creating tags"
        exit 1
      fi
    fi

    echo "\
v${vmajor}.${vminor} initialized"

  # New minor of existing major init
  elif ! exist_vminor "$vmajor" "$vminor" development; then
    if ! askYes "\
Are you sure you want to init the version ${vmajor}.${vminor}" "No"
    then 
      echo "\
Version initialization canceled!"
      exit 2
    fi
      
    init_vminor "$vmajor" "$vminor" && success=true
    
    if [ "$success" == true ]; then 
      echo "\
Created branches"
    else
      echoerr "\
Cannot be successfully initialized because a failure creating branches"
      exit 1
    fi
    
    echo "\
v${vmajor}.${vminor} initialized"

  elif [ "$OPTFEATURE" != true ]; then
    echoerr "\
v${vmajor}.${vminor} already exists"
    exit 1
  fi
  
  # New feature init
  if [ "$OPTFEATURE" == true ]; then
    success=false
    
    if exist_feature "$vmajor" "$vminor" "$feature_name"; then
      echoerr "\
Feature '${feature_name}' for version ${vmajor}.${vminor} already exists"
      exit 1
    fi
    
    if ! askYes "\
Init the feature '${feature_name}' for version ${vmajor}.${vminor}" "No"
    then 
      echo "\
Feature initialization canceled!"
      exit 2
    fi
    
    init_feature "$vmajor" "$vminor" "$feature_name" && success=true
    
    if [ "$success" == true ]; then 
      echo "\
Created branches"
    else
      echoerr "\
Cannot be successfully initialized because a failure creating branches"
      exit 1
    fi
  fi

}


do_list()
{
  local version=${1:-"."}

  echodbg "usa ls\n"
  echodbg "version: $version\n"
  echodbg "format: $OPTFORMAT\n"
  echodbg "nofeatures: $OPTNOFEATURES\n"
  echodbg "purpose: $OPTPURPOSE\n"
  echodbg "latest: $OPTLATEST\n"
  
  local vmajor=`extract_vmajor $version`
  local vminor=`extract_vminor $version`
  local vrev=`extract_vrev $version`
  local vstatus=`extract_vstatus $version`
  
  local currentversions="`get_currentversions`"
  local currentfeature="`get_currentfeature`"
  
  local versions="`get_versions "$OPTPURPOSE" "$vmajor" "$vminor" "$vrev" \
    "$vstatus" | sort --version-sort`"
    
  local one_version
  local features_forversion
  local one_feature
  
  if [ "$OPTLATEST" == true ]; then
    versions="`echo "$versions" | tail -n 1`"
  fi

  if [ "$versions" != "" ]; then
    echo "$versions" | \
    while IFS='' read -r one_version || [[ -n "$one_version" ]]; do
  
      if [ "`echo "$currentversions" | grep "^${one_version}$"`" == "" ]; then
        echo "  $one_version"
      else
        echo "* $one_version"
      fi
    
      # List features for each development version
      [ "$OPTNOFEATURES" != true ] \
      && features_forversion="`get_features_forversion "$one_version"`"
      if [ "$features_forversion" != "" ]; then
        echo "$features_forversion" | \
        while IFS='' read -r one_feature || [[ -n "$one_feature" ]]; do
      
          if [ "`echo "$currentfeature" | grep "^${one_feature}$"`" == "" ]
          then
            echo "    $one_feature"
          else
            echo "  * $one_feature"
          fi
        done
      fi

    done
  fi
  
  

#  case "$OPTPURPOSE" in
#    general )
#      get_versions "$OPTPURPOSE" "$vmajor" "$vminor" "$vrev" "$vstatus"
#      ;;
#    development )
#      get_versions "$OPTPURPOSE" "$vmajor" "$vminor" "$vrev" "$vstatus"
#      ;;
#    testing )
#      get_versions "$OPTPURPOSE" "$vmajor" "$vminor" "$vrev" "$vstatus"
#      ;;
#    production )
#      get_versions "$OPTPURPOSE" "$vmajor" "$vminor" "$vrev" "$vstatus"
#      ;;
#    * )
#      echoerr "\
#internal. do_list() for $OPTPURPOSE"
#      exit 1
#      ;;
#  esac
  
  
}


do_status()
{
  local currentpurpose="`get_currentpurpose`"
  local stage_txt
  local vtype_txt
  local latestvrev_txt
  local output=""

  if ! is_initialized; then
    show_notinitialized_error
    exit 1
  fi
  
  # First line
  output=""
  
  case "$currentpurpose" in
    development )
      output="DEVELOPING"
      ;;
    testing )
      output="TESTING"
      ;;
    production )
      output="PRODUCTION"
      ;;
    * )
      echo "\
Not in a version"
      exit 1
      ;;
  esac
  
  local currentversion="`get_currentversion`"
  local vmajor="`extract_vmajor $currentversion`"
  local vminor="`extract_vminor $currentversion`"
 
  output="${output} on VERSION $currentversion"
  
  if is_infeature; then
    output="${output}, on FEATURE '`get_currentfeature`'"
  fi
  
  echo "$output"
  
  # Second line
  output=""
  
  case "`get_vtype $currentversion`" in
    cuttingedge )
      output="Version type is cutting-edge (head in major and head in minor)"
      ;;
    maintenance1 )
      output="Version type is maintenance-1 (only head in minor)"
      ;;
    maintenance2 )
      output="Version type is maintenance-2 (not head in minor)"
      ;;
  esac
  
  echo "$output"
  
  # Third line
  output=""
  
  local latestvrev="`get_latestvrev "$vmajor" "$vminor" "general"`"
  
  if [[ "$currentpurpose" == "development" ]]
  then
    if [ "$latestvrev" != "" ]; then
      output="Latest released revision is '${latestvrev}'. \
      Latest status is '`get_latestvstatus "$vmajor" "$vminor" "general"`'"
    else
      output="Revision has not been released yet"
    fi
  else
    if is_latestvrev $currentversion; then 
      output="You are in the latest revision"
    else
      output="You are not in the latest revision (which is ${latestvrev})"
    fi
  fi
  
  echo $output
  
  # Fourth line
  output=""
  
  if vcs_exist_uncommittedchanges; then
    output="There are uncommitted changes"
    if [ "$currentpurpose" != "development" ]; then
      output="$output (DO NOT COMMIT THEM!! YOU ARE NOT IN DEVELOPMENT VERSION)"
    fi
  fi
  
  if vcs_is_branchahead; then
    if [ "$output" != "" ]; then
      output="${output} and unreleased commits"
    else
      output="There are unreleased commits"
    fi
  fi
  
  echo $output
}


do_checkout()
{
  local version=${1:-"."}

  echodbg "version: $version\n"
  echodbg "feature: $OPTFEATURE\n"
  echodbg "feature name: $feature_name\n"
  echodbg "init: $OPTINIT\n"
  echodbg "purpose: $OPTPURPOSE\n"
  
  vmajor=`extract_vmajor $version`
  vminor=`extract_vminor $version`
  vrev=`extract_vrev $version`
  vstatus=`extract_vstatus $version`
      
  case "$OPTPURPOSE" in
    
    development )
      # Checkout to DEVELOPMENT version
      
      if [ "$vmajor" == "" ] || [ "$vminor" == "" ]; then
        # There was empty needed field
        
        echoerr "\
Version not completely specified as {major}.{minor}"
        show_checkoutversion_suggestion development "$vmajor" "$vminor"
        exit 1        
      fi
      
      if [ "$vrev" != "" ] || [ "$vstatus" != "" ]; then
        # User was trying to checkout to test or prod version number
        
        echoerr "\
Development version can only be specified as {major}.{minor}
To checkout a version for testing or production, use a command like this:

  $ ${0##*/} checkout v{major}.{minor}.{rev}-(alpha|beta|rc)
or

  $ ${0##*/} checkout v{major}.{minor}.{rev}-stable"
        exit 1
      fi
        
      if ! exist_version "$OPTPURPOSE" "${vmajor}" "${vminor}"; then
        # Version does not exist
        
        echoerr "\
v${vmajor}.${vminor} did not match any existing version for development.
To checkout and initialize it as a new version, use:

  $ ${0##*/} checkout v${vmajor}.${vminor} --init"
        exit 1
      fi
      
      if vcs_exist_uncommittedchanges; then
        echo "\
There are uncommitted changes.

These changes can cause:
- Unpredictable behaviour when execute or compile the version you are 
  checking-out if these files are kept after checking-out.
- Version control system error or changes overwritting if other version of these
  files exists in the checked-out version.

Instead of continuing with the checkout, it is recommended to:
- Stash the files with changes or move them to a temporary directory.
- Commit the changes.
"
        if ! askYes "Do you want to continue with the checkout?" "n"; then
          echo "Cancelled"
          exit 2
        fi
      fi
      
      if [ "$OPTFEATURE" == true ]; then
        # Checking out to FEATURE
      
        if ! exist_feature "$vmajor" "$vminor" "$feature_name"; then
          # Feature already exists 
          
          echoerr "\
Feature \'${feature_name}\' for version ${vmajor}.${vminor} does not exists
To checkout and initialize it as a new feature, use:

$ ${0##*/} checkout v${vmajor}.$vminor --feature \"${feature_name}\" --init"
          exit 1
        fi
        echo "\
Checking out to branch 'dev/v${vmajor}.${vminor}f/${feature_name}'"
        vcs_checkout "dev/v${vmajor}.${vminor}f/${feature_name}"

      else
        # Checking out to Development VERSION
      
        echo "\
Checking out to branch 'dev/v${vmajor}.${vminor}'"
        vcs_checkout "dev/v${vmajor}.${vminor}"
      fi
      ;;
    
    testing )
      # Checkout to TESTING version
      
      if [ "$OPTFEATURE" == true ]; then
        # User was trying to checkout to a feature for a released version
        
        echoerr "\
Feature development can only be performed over development versions"
        exit 1
      fi

      if [ "$vmajor" == "" ] || [ "$vminor" == "" ] || [ "$vrev" == "" ] || \
        [ "$vstatus" == "" ]; then
        # There was empty field
        
        echoerr "\
Version not completely specified as {major}.{minor}.{rev}-{status}"
        show_checkoutversion_suggestion testing "$vmajor" "$vminor" \
          "$vrev" "$vstatus"
        exit 1
      fi
      
      if ! exist_version "$OPTPURPOSE" "${vmajor}" "${vminor}" "${vrev}" \
        "${vstatus}"; then
        # Version does not exist
        
        echoerr "\
v${vmajor}.${vminor}.${vrev}-${vstatus} did not match any released \
version for testing."
        exit 1
      fi
      
      # Checking out to testing version
      echo "\
Checking out to the version: v${vmajor}.${vminor}.${vrev}-${vstatus}"
      vcs_checkout "v${vmajor}.${vminor}.${vrev}-${vstatus}"
      ;;
      
    production )
      # Checkout to PRODUCTION version
      
      if [ "$OPTFEATURE" == true ]; then
        # User was trying to checkout to a feature for a released version

        echoerr "\
Feature development can only be performed over development versions"
        exit 1
      fi
    
      if [[ "$vmajor" == "" || "$vminor" == "" || "$vrev" == "" || \
        ( "$vstatus" != "" && "$vstatus" != "stable" ) ]]; then
        # There was empty needed field or vstatus conflict
        
        echoerr "\
Version not completely specified as {major}.{minor}.{rev}-stable"
        show_checkoutversion_suggestion production "$vmajor" "$vminor" \
          "$vrev" "stable"
        exit 1
      fi
      
      if ! exist_version "$OPTPURPOSE" "${vmajor}" "${vminor}" "${vrev}" \
        stable; then
        # Version does not exist

        echoerr "\
v${vmajor}.${vminor}.${vrev}-stable did not match any released \
version for production."
        if [[ "$vstatus" == "" && "$vrev" != "" ]]; then
          show_checkoutversion_suggestion "testing" "$vmajor" "$vminor" \
            "$vrev"
        fi
        exit 1
      fi

      # Checking out to production version
      echo "\
Checking out to the version: v${vmajor}.${vminor}.${vrev}-stable"
      vcs_checkout "v${vmajor}.${vminor}.${vrev}-stable"
      ;;
    
    "" )
      # ERROR
      
      echoerr "\
Version must be specified"
      echo
      show_checkoutversion_suggestion development "$vmajor" "$vminor" \
        "$vrev" "$vstatus"
      echo
      show_checkoutversion_suggestion testing "$vmajor" "$vminor" \
        "$vrev" "$vstatus"
      echo
      show_checkoutversion_suggestion production "$vmajor" "$vminor" \
        "$vrev" "$vstatus"
      ;;
    
    * )
      # ERROR
      
      echoerr "\
internal: Unknown purpose to checkout version"
      exit 1
      ;;
  esac
  
}


do_release()
{
  local version=${1:-"."}

  echodbg "usa release\n"
  echodbg "feature: $OPTFEATURE\n"
  echodbg "feature name: $feature_name\n"

  local vmajor="`extract_vmajor $version`"
  local vminor="`extract_vminor $version`"
  local vrev="`extract_vrev $version`"
  local vstatus="`extract_vstatus $version`"

  local success=false
  local nextvrev
  local currentpurpose
  local latestvstatus
  
  if [ "$OPTFEATURE" == true ]; then
    if [[ "$vmajor" == "" || "$vminor" == "" ]]; then
      show_releasefeature_suggestion "" "" ""
      exit 1
    elif [ "$feature_name" == "" ]; then
      show_releasefeature_suggestion "$vmajor" "$vminor" ""
      exit 1
    elif [[ "$vrev" != "" || "$vstatus" != "" ]]; then
      show_releasefeature_suggestion "$vmajor" "$vminor" "$feature_name"
      exit 1
    elif ! exist_feature "$vmajor" "$vminor" "$feature_name"; then
      echoerr "\
The feature '$feature_name' does not exist for version ${vmajor}.${vminor}"
      exit 1
    else
    
      if ! askYes "\
End development of feature '${feature_name}' for version ${vmajor}.${vminor}?
Note: this will merge the feature branch into the version development branch and
delete the feature branch" "No"
      then 
        echo "\
Feature releasing canceled!"
        exit 2
      fi
      
      end_feature "$vmajor" "$vminor" "$feature_name" && success=true
      
      if [ "$success" == true ]; then 
        echo "\
Feature branch merged and deleted"
      else
        echoerr "\
Cannot be successfully released because a failure merging or removing branch"
        exit 1
      fi
      
    fi
    
    exit 0
  fi
  
  
  if [ "$vmajor" == "" ] || [ "$vminor" == "" ] || [ "$vrev" == "" ] || \
    [ "$vstatus" == "" ]; then
    # Show error and suggestion
    show_releaseversion_suggestion
    exit 1
  fi
      
  case $vstatus in
    alpha | beta | rc )  # Release for testing
      # Comprobacion de HEAD en rama de desarrollo de la version a liberar
      if [ "`get_currentpurpose`" != "development" ] || \
        [ "`get_currentversion`" != "v${vmajor}.${vminor}" ]; then
        echoerr "\
Not in developing stage for v${vmajor}.${vminor}"
        show_checkoutversion_suggestion development "$vmajor" "$vminor"
        exit 1
      fi
      # Comprobacion de no existencia de la version a liberar
      if exist_version testing "$vmajor" "$vminor" "$vrev" "$vstatus"; then
        echoerr "\
v${vmajor}.${vminor}.${vrev}-${vstatus} already exists"
        exit 1
      fi
      # Comprobacion de numero de revision correcto
      latestvrev=`get_latestvrev "$vmajor" "$vminor" general`
      nextvrev=$(get_nextvrev "$vmajor" "$vminor")
      if [ $nextvrev -ne $vrev ]; then
        echoerr "\
Given revision number (${vrev}) must be consecutive to the latest one. Use:

    $ ${0##*/} release v${vmajor}.${vminor}.${nextvrev}-\
`get_latestvstatus "$vmajor" "$vminor" "testing"`"
        exit 1
      fi 
      # Comprobacion de no retroceso en el estado cuando no admitido
      if [ "$vstatus" != "rc" ] && \
        is_pastvstatus "$vmajor" "$vminor" "$vstatus"; then
        echoerr "\
Cannot back to a past status (except to rc). Use at least \
'`get_latestvstatus "$vmajor" "$vminor" "testing"`'"
        exit 1
      fi
      
      show_releasefortesting_warning
      
      if askYes "\
Are you sure you want to release the version \
${vmajor}.${vminor}.${vrev}-${vstatus}" "No"
      then 
        echo "v${vmajor}.${vminor}.${vrev}-${vstatus} will be released"
      else
        echo "\
Canceled!"
        exit 2
      fi
      
      # Creación de la etiqueta v{major}.{minor}.{rev}-{status}   ◄◄◄
      vcs_create_lightweighttag "v${vmajor}.${vminor}.${vrev}-${vstatus}" && \
      # Creación de la etiqueta v{major}.{minor}-{status}{status_rev}
      local vstatusrev=`get_nextvstatusrev "$vmajor" "$vminor" "$vstatus"` && \
      vcs_create_lightweighttag "v${vmajor}.${vminor}-${vstatus}${vstatusrev}" \
      && echo "\
Created tags" || ( echoerr "\
Cannot be successfully released because a failure creating tags"; exit 1 )

      case "`get_vtype $version`" in
        cuttingedge )
          # Se suben los cambios locales de la rama dev/v{major}.{minor}, si hay remote
          # Se fusiona la rama dev/v{major}.{minor} con la rama test/v{major}.{minor} con fast-forward
          # Se fusiona la rama test/v{major}.{minor} con la rama test/v{major} con fast-forward
          # Se fusiona la rama test/v{major} con la rama test/cutting-edge con fast-forward
          vcs_push_branch "dev/v${vmajor}.${vminor}" \
          && vcs_merge_branch_ff "dev/v${vmajor}.${vminor}" \
            "test/v${vmajor}.${vminor}" \
          && vcs_merge_branch_ff "test/v${vmajor}.${vminor}" \
            "test/v${vmajor}" \
          && vcs_merge_branch_ff "test/v${vmajor}" "test/cutting-edge" \
          && echo "\
Merged branches" || ( echoerr "\
Cannot be successfully released because a failure merging branches"; exit 1 )
          ;;
        maintenance1 )
          # Se suben los cambios locales de la rama dev/v{major}.{minor}, si hay remote
          # Se fusiona la rama dev/v{major}.{minor} con la rama test/v{major}.{minor} con fast-forward
          # Se fusiona la rama test/v{major}.{minor} con la rama test/v{major} con fast-forward
          vcs_push_branch "dev/v${vmajor}.${vminor}" \
          && vcs_merge_branch_ff "dev/v${vmajor}.${vminor}" \
            "test/v${vmajor}.${vminor}" \
          && vcs_merge_branch_ff "test/v${vmajor}.${vminor}" \
            "test/v${vmajor}" \
          && echo "\
Merged branches" || ( echoerr "\
Cannot be successfully released because a failure merging branches"; exit 1 )
          ;;
        maintenance2 )
          # Se suben los cambios locales de la rama dev/v{major}.{minor}, si hay remote
          # Se fusiona la rama dev/v{major}.{minor} con la rama test/v{major}.{minor} con fast-forward
          vcs_push_branch "dev/v${vmajor}.${vminor}" \
          && vcs_merge_branch_ff "dev/v${vmajor}.${vminor}" \
            "test/v${vmajor}.${vminor}" \
          && echo "\
Merged branches" || ( echoerr "\
Cannot be successfully released because a failure merging branches"; exit 1 )
          ;;
      esac
      
      do_releasefortesting_extra && show_releasefortesting_extra_success \
      || show_releasefortesting_extra_error
      ;;

    stable )  # Release for production
      # Comprobacion de HEAD en version rc correspondiente a version a liberar
      if [ "`get_currentversion`" != "v${vmajor}.${vminor}.${vrev}-rc" ]; then
        echoerr "\
Not in rc version v${vmajor}.${vminor}.${vrev}-rc"
        show_checkoutversion_suggestion testing "$vmajor" "$vminor" "$vrev" rc
        exit 1
      fi
      # Comprobacion de no existencia de la version a liberar
      if exist_version production "$vmajor" "$vminor" "$vrev" "$vstatus"; then
        echoerr "\
v${vmajor}.${vminor}.${vrev}-${vstatus} already exists"
        exit 1
      fi
      
      show_releaseforproduction_warning

      # Comprobacion de si se libera una revision posterior a la ultima liberada
      latestvrev=`get_latestvrev "$vmajor" "$vminor" production`
      if [[ "$latestvrev" != "" && $latestvrev -gt $vrev ]]; then
        echo "\
note: You are releasing an older rev than the latest released for production"
      fi 
      
      if askYes "\
Are you sure you want to release the version \
${vmajor}.${vminor}.${vrev}-${vstatus}" "No"
      then 
        echo "v${vmajor}.${vminor}.${vrev}-${vstatus} will be released"
      else
        echo "\
Canceled!"
        exit 2
      fi
      
      # Creación de la etiqueta v{major}.{minor}.{rev}-{status}   ◄◄◄
      vcs_create_lightweighttag "v${vmajor}.${vminor}.${vrev}-${vstatus}" && \
      # Creación de la etiqueta v{major}.{minor}.{rev}
      vcs_create_lightweighttag "v${vmajor}.${vminor}.${vrev}" && tagok=true
      # Creación de la etiqueta v{major}.{minor}-{status}{status_rev}
      if [[ "$tagok" == true && "$latestvrev" != "" && $latestvrev -lt $vrev ]]
      then
        tagok=false
        local vstatusrev=`get_nextvstatusrev "$vmajor" "$vminor" "$vstatus"` && \
        vcs_create_lightweighttag \
          "v${vmajor}.${vminor}-${vstatus}${vstatusrev}" && tagok=true
      fi
      if [ "$tagok" == true ]; then echo "\
Created tags"
      else echoerr "\
Cannot be successfully released because a failure creating tags"; exit 1
      fi

      if [[ "$latestvrev" == "" || $latestvrev -lt $vrev ]]; then
        case "`get_vtype $version`" in
          cuttingedge )
            # Se fusiona hasta la etiqueta v{major}.{minor}.{rev}-rc con la rama v{major}.{minor} con fast-forward
            vcs_merge_branch_ff "v${vmajor}.${vminor}.${vrev}-${vstatus}" \
              "v${vmajor}.${vminor}" && \
            # Se fusiona la rama v{major}.{minor} con la rama v{major} con fast-forward
            vcs_merge_branch_ff "v${vmajor}.${vminor}" "v${vmajor}" && \
            # Se fusiona la rama v{major} con la rama cutting-edge con fast-forward
            vcs_merge_branch_ff "v${vmajor}" "$CUTTINGEDGE_BRANCH" && \
            echo "\
Merged branches" || ( echoerr "\
Cannot be successfully released because a failure merging branches"; exit 1 )
            ;;
          maintenance1 )
            # Se fusiona hasta la etiqueta v{major}.{minor}.{rev}-rc con la rama v{major}.{minor} con fast-forward
            vcs_merge_branch_ff "v${vmajor}.${vminor}.${vrev}-${vstatus}" \
              "v${vmajor}.${vminor}" && \
            # Se fusiona la rama v{major}.{minor} con la rama v{major} con fast-forward
            vcs_merge_branch_ff "v${vmajor}.${vminor}" "v${vmajor}" && \
            echo "\
Merged branches" || ( echoerr "\
Cannot be successfully released because a failure merging branches"; exit 1 )
            ;;
          maintenance2 )
            # Se fusiona hasta la etiqueta v{major}.{minor}.{rev}-rc con la rama v{major}.{minor} con fast-forward
            vcs_merge_branch_ff "v${vmajor}.${vminor}.${vrev}-${vstatus}" \
              "v${vmajor}.${vminor}" && \
            echo "\
Merged branches" || ( echoerr "\
Cannot be successfully released because a failure merging branches"; exit 1 )
            ;;
        esac
      fi 
      
      do_releaseforproduction_extra && show_releaseforproduction_extra_success \
      || show_releaseforproduction_extra_error
      ;;
      
    * )
      echoerr "\
Invalid version number. Version status must be (alpha|beta|rc|stable)."
      ;;
    esac
}


do_sync()
{
  #TODO
  echo "Feature To Do..."
#  if [ "$USE_REMOTE" == true ]; then
#    echo "Fetching updated data from remote repository..."
#    git fetch $REMOTE_ALIAS --tags
#    echo "Pushing branches of development versions..."
#    git push $REMOTE_ALIAS "dev/v*0"
#    echo "Pushing branches of testing versions..."
#    git push $REMOTE_ALIAS "test/v[0-9]*\.[0-9]*:test/v[0-9]*\.[0-9]*"
#    echo "Pushing branches of production versions..."
#    git push $REMOTE_ALIAS "v[0-9]*\.[0-9]*:"
#    echo "Pushing tags of released versions..."
#    git push $REMOTE_ALIAS --tags
#  fi
}




