#!/bin/bash


###############################################################################
# Fluho
# Controller
#
# Written by Juan Jose Castro Sotelo
# Licensed under terms of GPLv3
#
###############################################################################




do_init()
{
  echodbg "usa init\n"
  echodbg "version: $version\n"
  echodbg "feature: $OPTFEATURE\n"  # TODO
  echodbg "feature name: $feature_name\n"  # TODO
  
  local version=$1
  
  local vmajor=`extract_vmajor $version`
  local vminor=`extract_vminor $version`
  local vrev=`extract_vrev $version`
  local vstatus=`extract_vstatus $version`
  
  local success=false
  
  if [ "$OPTFEATURE" == true ]; then
    echo "'feature' option still as ToDo."
    exit 1
  fi
  
  vmajor=${vmajor:-0}
  vminor=${vminor:-0}
  
  if [ "$vrev" != "" -o "$vstatus" != "" ]; then
    echoerr "\
Only major.minor version can be initialized. Use:

    $ ${0##*/} init ${vmajor}.${vminor}"
    exit 1
  fi
  if ! exist_vmajor "$vmajor" development; then
    if [ $vmajor -ne 0 -o $vminor -ne 0 ] && ! is_initialized; then
      show_notinitialized_error
      exit 1  
    fi

    if ! askYes "\
Are you sure you want to init the version ${vmajor}.${vminor}" "No"
    then 
      echo "\
Canceled!"
      exit 2
    fi
      
    init_vmajor "$vmajor" "$vminor" && success=true 

    if [ "$success" == true ]; then 
      echo "\
Created branches"
    else
      echoerr "\
Cannot be successfully initialized because a failure creating branches
Does the cutting-edge branch exist and is it correctly initialized?"
      exit 1
    fi
    
    if [ $vmajor -eq 0 -a $vminor -eq 0 ]; then
      # Start versioning in a new repo
      vcs_create_lightweighttag "v0.0.0-alpha" && \
      vcs_create_lightweighttag "v0.0-alpha1" && \
      vcs_create_lightweighttag "v0.0.0" && success=true
      if [ "$success" == true ]; then 
        echo "\
Created tags"
        vcs_checkout "dev/v0.0"
      else
        echoerr "\
Cannot be successfully initialized because a failure creating tags"
        exit 1
      fi
    fi

    echo "\
v${vmajor}.${vminor} initialized"

  elif ! exist_vminor "$vmajor" "$vminor" development; then
    if ! askYes "\
Are you sure you want to init the version ${vmajor}.${vminor}" "No"
    then 
      echo "\
Canceled!"
      exit 2
    fi
      
    init_vminor "$vmajor" "$vminor" && success=true
    
    if [ "$success" == true ]; then 
      echo "\
Created branches"
    else
      echoerr "\
Cannot be successfully initialized because a failure creating branches"
      exit 1
    fi
    
    echo "\
v${vmajor}.${vminor} initialized"

  else
    echoerr "\
v${vmajor}.${vminor} already exists"
    exit 1
  fi
}


do_list()
{
  local version=${1:-"."}

  echodbg "usa ls\n"
  echodbg "version: $version\n"
  echodbg "format: $OPTFORMAT\n"
  echodbg "feature: $feature_name\n"  # TODO
  echodbg "purpose: $OPTPURPOSE\n"
  echodbg "latest: $OPTLATEST\n"
  
  local vmajor=`extract_vmajor $version`
  local vminor=`extract_vminor $version`
  local vrev=`extract_vrev $version`
  local vstatus=`extract_vstatus $version`
  
  local currentversions="`get_currentversions`"
  
  local versions="`get_versions "$OPTPURPOSE" "$vmajor" "$vminor" "$vrev" \
    "$vstatus" | sort --version-sort`"
  
  if [ "$OPTLATEST" == true ]; then
    versions="`echo "$versions" | tail -n 1`"
  fi

 [ "$versions" != "" ] && echo "$versions" \
  | while IFS='' read -r one_version || [[ -n "$one_version" ]]; do
    if [ "`echo "$currentversions" | grep "^${one_version}$"`" == "" ]; then
      echo "  $one_version"
    else
      echo "* $one_version"
    fi
  done
  
  

#  case "$OPTPURPOSE" in
#    general )
#      get_versions "$OPTPURPOSE" "$vmajor" "$vminor" "$vrev" "$vstatus"
#      ;;
#    development )
#      get_versions "$OPTPURPOSE" "$vmajor" "$vminor" "$vrev" "$vstatus"
#      ;;
#    testing )
#      get_versions "$OPTPURPOSE" "$vmajor" "$vminor" "$vrev" "$vstatus"
#      ;;
#    production )
#      get_versions "$OPTPURPOSE" "$vmajor" "$vminor" "$vrev" "$vstatus"
#      ;;
#    * )
#      echoerr "\
#internal. do_list() for $OPTPURPOSE"
#      exit 1
#      ;;
#  esac
  
  
}


do_status()
{
  local currentpurpose=`get_currentpurpose`
  local stage_txt
  local vtype_txt
  local latestvrev_txt
  local output=""

  if ! is_initialized; then
    show_notinitialized_error
    exit 1
  fi
  
  case "$currentpurpose" in
    development )
      output="Developing"
      ;;
    testing )
      output="Testing"
      ;;
    production )
      output="Production"
      ;;
    * )
      echo "\
Not in a version"
      exit 1
      ;;
  esac
  
  local currentversion="`get_currentversion`"
  local vmajor="`extract_vmajor $currentversion`"
  local vminor="`extract_vminor $currentversion`"
 
  output="${output}, on version $currentversion"
  
  echo "$output"
  
  case "`get_vtype $currentversion`" in
    cuttingedge )
      output="Version type is cutting-edge (head in major and head in minor)"
      ;;
    maintenance1 )
      output="Version type is maintenance-1 (only head in minor)"
      ;;
    maintenance2 )
      output="Version type is maintenance-2 (not head in minor)"
      ;;
  esac
  
  echo "$output"
  
  local latestvrev="`get_latestvrev "$vmajor" "$vminor" "general"`"
  
  if [[ "$currentpurpose" == "development" ]]
  then
    if [ "$latestvrev" != "" ]; then
      output="Latest revision is '${latestvrev}'. \
      Latest status is '`get_latestvstatus "$vmajor" "$vminor" "general"`'"
    else
      output="Revision has not been released yet"
    fi
  else
    if is_latestvrev $currentversion; then 
      output="You are in the latest revision"
    else
      output="You are not in the latest revision (which is ${latestvrev})"
    fi
  fi
  
  echo $output
}


do_checkout()
{
  local version=${1:-"."}

  echodbg "version: $version\n"
  echodbg "feature: $OPTFEATURE\n"
  echodbg "feature name: $feature_name\n"  # TODO
  echodbg "init: $OPTINIT\n"
  echodbg "purpose: $OPTPURPOSE\n"
  
  if [ "$OPTFEATURE" == true ]; then
    echo "'feature' option still as ToDo."
    exit 1
  fi
  
  vmajor=`extract_vmajor $version`
  vminor=`extract_vminor $version`
  vrev=`extract_vrev $version`
  vstatus=`extract_vstatus $version`
      
  case "$OPTPURPOSE" in
    development )
      if [ "$vmajor" == "" ] || [ "$vminor" == "" ]; then
        
        # There was empty needed field
        echoerr "\
Version not completely specified as {major}.{minor}"
        show_checkoutversion_suggestion development "$vmajor" "$vminor"
        exit 1
        
      else
      
        # There was no empty needed field
        if [ "$vrev" != "" ] || [ "$vstatus" != "" ]; then
          echoerr "\
Development version can only be specified as {major}.{minor}
To checkout a version for testing or production, use a command like this:
$ ${0##*/} checkout v{major}.{minor}.{rev}-(alpha|beta|rc)
or
$ ${0##*/} checkout v{major}.{minor}.{rev}-stable"
          exit 1
        fi
        if ! exist_version "$OPTPURPOSE" "${vmajor}" "${vminor}"; then
          echoerr "\
v${vmajor}.${vminor} did not match any existing version for development.
To checkout and initialize it as a new version, use:

    $ ${0##*/} checkout v${vmajor}.${vminor} --init"
          exit 1
        else
          echo "\
Checking out to branch 'dev/v${vmajor}.${vminor}'"
          vcs_checkout "dev/v${vmajor}.${vminor}"
        fi
        
      fi
      ;;
    
    testing )
      if [ "$vmajor" == "" ] || [ "$vminor" == "" ] || [ "$vrev" == "" ] || \
        [ "$vstatus" == "" ]; then
        
        # There was empty field
        echoerr "\
Version not completely specified as {major}.{minor}.{rev}-{status}"
        show_checkoutversion_suggestion testing "$vmajor" "$vminor" \
          "$vrev" "$vstatus"
        exit 1
                
      else
      
        # There was no empty field
        if ! exist_version "$OPTPURPOSE" "${vmajor}" "${vminor}" "${vrev}" \
          "${vstatus}"
        then
          echoerr "\
v${vmajor}.${vminor}.${vrev}-${vstatus} did not match any released \
version for testing."
          exit 1
        else
          echo "\
Checking out to the version: v${vmajor}.${vminor}.${vrev}-${vstatus}"
          vcs_checkout "v${vmajor}.${vminor}.${vrev}-${vstatus}"
        fi
        
      fi
      ;;
      
    production )
    
      if [[ "$vmajor" == "" || "$vminor" == "" || "$vrev" == "" || \
        ( "$vstatus" != "" && "$vstatus" != "stable" ) ]]; then
        # There was empty needed field or vstatus conflict
        
        echoerr "\
Version not completely specified as {major}.{minor}.{rev}-stable"
        show_checkoutversion_suggestion production "$vmajor" "$vminor" \
          "$vrev" "stable"
        exit 1
                
      else
        # There was no empty field
      
        if ! exist_version "$OPTPURPOSE" "${vmajor}" "${vminor}" "${vrev}" \
          stable; then
          echoerr "\
v${vmajor}.${vminor}.${vrev}-stable did not match any released \
version for production."
          if [[ "$vstatus" == "" && "$vrev" != "" ]]; then
            show_checkoutversion_suggestion "testing" "$vmajor" "$vminor" \
              "$vrev"
          fi
          exit 1
        else
          echo "\
Checking out to the version: v${vmajor}.${vminor}.${vrev}-stable"
          vcs_checkout "v${vmajor}.${vminor}.${vrev}-stable"
        fi
        
      fi
      ;;
    
    "" )
      echoerr "\
Version must be specified"
      echo
      show_checkoutversion_suggestion development "$vmajor" "$vminor" \
        "$vrev" "$vstatus"
      echo
      show_checkoutversion_suggestion testing "$vmajor" "$vminor" \
        "$vrev" "$vstatus"
      echo
      show_checkoutversion_suggestion production "$vmajor" "$vminor" \
        "$vrev" "$vstatus"
      ;;
    
    * )
      echoerr "\
internal: Unknown purpose to checkout version"
      exit 1
      ;;
  esac
  
}


do_release()
{
  local version=${1:-"."}

  echodbg "usa release\n"
  echodbg "feature: $OPTFEATURE\n"  # TODO
  echodbg "feature name: $feature_name\n"  # TODO

  local vmajor="`extract_vmajor $version`"
  local vminor="`extract_vminor $version`"
  local vrev="`extract_vrev $version`"
  local vstatus="`extract_vstatus $version`"

  local nextvrev
  local currentpurpose
  local latestvstatus
  
  if [ "$OPTFEATURE" == true ]; then
    echo "'feature' option still as ToDo."
    exit 1
  fi
  
  if [ "$vmajor" == "" ] || [ "$vminor" == "" ] || [ "$vrev" == "" ] || \
    [ "$vstatus" == "" ]; then
    # Show error and suggestion
    vmajor=$(get_currentvmajor); vmajor=${vmajor:-0}
    vminor=$(get_currentvminor); vminor=${vminor:-0}
    currentpurpose=$(get_currentpurpose)
    currentpurpose=${currentpurpose:-general}
    case "$currentpurpose" in
      development ) 
        latestvstatus=$(get_latestvstatus "$vmajor" "$vminor" "testing")
        nextvrev=$(get_nextvrev "$vmajor" "$vminor")
        ;;
      * )
        latestvstatus=$(get_latestvstatus "$vmajor" "$vminor" "general")
        nextvrev=$(get_currentvrev); nextvrev=${nextvrev:-0}
    esac
    latestvstatus=${latestvstatus:-alpha}
    echoerr "\
Specify version to release. For example:

    $ ${0##*/} release v${vmajor}.${vminor}.${nextvrev}-$latestvstatus"
    exit 1
  fi
      
  case $vstatus in
    alpha | beta | rc )  # Release for testing
      # Comprobacion de HEAD en rama de desarrollo de la version a liberar
      if [ "`get_currentpurpose`" != "development" ] || \
        [ "`get_currentversion`" != "v${vmajor}.${vminor}" ]; then
        echoerr "\
Not in developing stage for v${vmajor}.${vminor}"
        show_checkoutversion_suggestion development "$vmajor" "$vminor"
        exit 1
      fi
      # Comprobacion de no existencia de la version a liberar
      if exist_version testing "$vmajor" "$vminor" "$vrev" "$vstatus"; then
        echoerr "\
v${vmajor}.${vminor}.${vrev}-${vstatus} already exists"
        exit 1
      fi
      # Comprobacion de numero de revision correcto
      latestvrev=`get_latestvrev "$vmajor" "$vminor" general`
      nextvrev=$(get_nextvrev "$vmajor" "$vminor")
      if [ $nextvrev -ne $vrev ]; then
        echoerr "\
Given revision number (${vrev}) must be consecutive to the latest one. Use:

    $ ${0##*/} release v${vmajor}.${vminor}.${nextvrev}-\
`get_latestvstatus "$vmajor" "$vminor" "testing"`"
        exit 1
      fi 
      # Comprobacion de no retroceso en el estado cuando no admitido
      if [ "$vstatus" != "rc" ] && \
        is_pastvstatus "$vmajor" "$vminor" "$vstatus"; then
        echoerr "\
Cannot back to a past status (except to rc). Use at least \
'`get_latestvstatus "$vmajor" "$vminor" "testing"`'"
        exit 1
      fi
      
      show_releasefortesting_warning
      
      if askYes "\
Are you sure you want to release the version \
${vmajor}.${vminor}.${vrev}-${vstatus}" "No"
      then 
        echo "v${vmajor}.${vminor}.${vrev}-${vstatus} will be released"
      else
        echo "\
Canceled!"
        exit 2
      fi
      
      # Creación de la etiqueta v{major}.{minor}.{rev}-{status}   ◄◄◄
      vcs_create_lightweighttag "v${vmajor}.${vminor}.${vrev}-${vstatus}" && \
      # Creación de la etiqueta v{major}.{minor}-{status}{status_rev}
      local vstatusrev=`get_nextvstatusrev "$vmajor" "$vminor" "$vstatus"` && \
      vcs_create_lightweighttag "v${vmajor}.${vminor}-${vstatus}${vstatusrev}" \
      && echo "\
Created tags" || ( echoerr "\
Cannot be successfully released because a failure creating tags"; exit 1 )

      case "`get_vtype $version`" in
        cuttingedge )
          # Se suben los cambios locales de la rama dev/v{major}.{minor}, si hay remote
          # Se fusiona la rama dev/v{major}.{minor} con la rama test/v{major}.{minor} con fast-forward
          # Se fusiona la rama test/v{major}.{minor} con la rama test/v{major} con fast-forward
          # Se fusiona la rama test/v{major} con la rama test/cutting-edge con fast-forward
          vcs_push_branch "dev/v${vmajor}.${vminor}" \
          && vcs_merge_branch_ff "dev/v${vmajor}.${vminor}" \
            "test/v${vmajor}.${vminor}" \
          && vcs_merge_branch_ff "test/v${vmajor}.${vminor}" \
            "test/v${vmajor}" \
          && vcs_merge_branch_ff "test/v${vmajor}" "test/cutting-edge" \
          && echo "\
Merged branches" || ( echoerr "\
Cannot be successfully released because a failure merging branches"; exit 1 )
          ;;
        maintenance1 )
          # Se suben los cambios locales de la rama dev/v{major}.{minor}, si hay remote
          # Se fusiona la rama dev/v{major}.{minor} con la rama test/v{major}.{minor} con fast-forward
          # Se fusiona la rama test/v{major}.{minor} con la rama test/v{major} con fast-forward
          vcs_push_branch "dev/v${vmajor}.${vminor}" \
          && vcs_merge_branch_ff "dev/v${vmajor}.${vminor}" \
            "test/v${vmajor}.${vminor}" \
          && vcs_merge_branch_ff "test/v${vmajor}.${vminor}" \
            "test/v${vmajor}" \
          && echo "\
Merged branches" || ( echoerr "\
Cannot be successfully released because a failure merging branches"; exit 1 )
          ;;
        maintenance2 )
          # Se suben los cambios locales de la rama dev/v{major}.{minor}, si hay remote
          # Se fusiona la rama dev/v{major}.{minor} con la rama test/v{major}.{minor} con fast-forward
          vcs_push_branch "dev/v${vmajor}.${vminor}" \
          && vcs_merge_branch_ff "dev/v${vmajor}.${vminor}" \
            "test/v${vmajor}.${vminor}" \
          && echo "\
Merged branches" || ( echoerr "\
Cannot be successfully released because a failure merging branches"; exit 1 )
          ;;
      esac
      
      do_releasefortesting_extra && show_releasefortesting_extra_success \
      || show_releasefortesting_extra_error
      ;;

    stable )  # Release for production
      # Comprobacion de HEAD en version rc correspondiente a version a liberar
      if [ "`get_currentversion`" != "v${vmajor}.${vminor}.${vrev}-rc" ]; then
        echoerr "\
Not in rc version v${vmajor}.${vminor}.${vrev}-rc"
        show_checkoutversion_suggestion testing "$vmajor" "$vminor" "$vrev" rc
        exit 1
      fi
      # Comprobacion de no existencia de la version a liberar
      if exist_version production "$vmajor" "$vminor" "$vrev" "$vstatus"; then
        echoerr "\
v${vmajor}.${vminor}.${vrev}-${vstatus} already exists"
        exit 1
      fi
      
      show_releaseforproduction_warning

      # Comprobacion de si se libera una revision posterior a la ultima liberada
      latestvrev=`get_latestvrev "$vmajor" "$vminor" production`
      if [[ "$latestvrev" != "" && $latestvrev -gt $vrev ]]; then
        echo "\
note: You are releasing an older rev than the latest released for production"
      fi 
      
      if askYes "\
Are you sure you want to release the version \
${vmajor}.${vminor}.${vrev}-${vstatus}" "No"
      then 
        echo "v${vmajor}.${vminor}.${vrev}-${vstatus} will be released"
      else
        echo "\
Canceled!"
        exit 2
      fi
      
      # Creación de la etiqueta v{major}.{minor}.{rev}-{status}   ◄◄◄
      vcs_create_lightweighttag "v${vmajor}.${vminor}.${vrev}-${vstatus}" && \
      # Creación de la etiqueta v{major}.{minor}.{rev}
      vcs_create_lightweighttag "v${vmajor}.${vminor}.${vrev}" && tagok=true
      # Creación de la etiqueta v{major}.{minor}-{status}{status_rev}
      if [[ "$tagok" == true && "$latestvrev" != "" && $latestvrev -lt $vrev ]]
      then
        tagok=false
        local vstatusrev=`get_nextvstatusrev "$vmajor" "$vminor" "$vstatus"` && \
        vcs_create_lightweighttag \
          "v${vmajor}.${vminor}-${vstatus}${vstatusrev}" && tagok=true
      fi
      if [ "$tagok" == true ]; then echo "\
Created tags"
      else echoerr "\
Cannot be successfully released because a failure creating tags"; exit 1
      fi

      if [[ "$latestvrev" == "" || $latestvrev -lt $vrev ]]; then
        case "`get_vtype $version`" in
          cuttingedge )
            # Se fusiona hasta la etiqueta v{major}.{minor}.{rev}-rc con la rama v{major}.{minor} con fast-forward
            vcs_merge_branch_ff "v${vmajor}.${vminor}.${vrev}-${vstatus}" \
              "v${vmajor}.${vminor}" && \
            # Se fusiona la rama v{major}.{minor} con la rama v{major} con fast-forward
            vcs_merge_branch_ff "v${vmajor}.${vminor}" "v${vmajor}" && \
            # Se fusiona la rama v{major} con la rama cutting-edge con fast-forward
            vcs_merge_branch_ff "v${vmajor}" "$CUTTINGEDGE_BRANCH" && \
            echo "\
Merged branches" || ( echoerr "\
Cannot be successfully released because a failure merging branches"; exit 1 )
            ;;
          maintenance1 )
            # Se fusiona hasta la etiqueta v{major}.{minor}.{rev}-rc con la rama v{major}.{minor} con fast-forward
            vcs_merge_branch_ff "v${vmajor}.${vminor}.${vrev}-${vstatus}" \
              "v${vmajor}.${vminor}" && \
            # Se fusiona la rama v{major}.{minor} con la rama v{major} con fast-forward
            vcs_merge_branch_ff "v${vmajor}.${vminor}" "v${vmajor}" && \
            echo "\
Merged branches" || ( echoerr "\
Cannot be successfully released because a failure merging branches"; exit 1 )
            ;;
          maintenance2 )
            # Se fusiona hasta la etiqueta v{major}.{minor}.{rev}-rc con la rama v{major}.{minor} con fast-forward
            vcs_merge_branch_ff "v${vmajor}.${vminor}.${vrev}-${vstatus}" \
              "v${vmajor}.${vminor}" && \
            echo "\
Merged branches" || ( echoerr "\
Cannot be successfully released because a failure merging branches"; exit 1 )
            ;;
        esac
      fi 
      
      do_releaseforproduction_extra && show_releaseforproduction_extra_success \
      || show_releaseforproduction_extra_error
      ;;
      
    * )
      echoerr "\
Invalid version number. Version status must be (alpha|beta|rc|stable)."
      ;;
    esac
}


do_sync()
{
  #TODO
  echo "Feature To Do..."
#  if [ "$USE_REMOTE" == true ]; then
#    echo "Fetching updated data from remote repository..."
#    git fetch $REMOTE_ALIAS --tags
#    echo "Pushing branches of development versions..."
#    git push $REMOTE_ALIAS "dev/v*0"
#    echo "Pushing branches of testing versions..."
#    git push $REMOTE_ALIAS "test/v[0-9]*\.[0-9]*:test/v[0-9]*\.[0-9]*"
#    echo "Pushing branches of production versions..."
#    git push $REMOTE_ALIAS "v[0-9]*\.[0-9]*:"
#    echo "Pushing tags of released versions..."
#    git push $REMOTE_ALIAS --tags
#  fi
}




